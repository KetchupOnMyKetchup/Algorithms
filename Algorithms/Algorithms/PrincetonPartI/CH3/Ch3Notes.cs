using System;
using System.Collections.Generic;
using System.Text;

namespace Algorithms.Algorithms.PrincetonPartI.CH3
{
    /// <summary>
    /// Upper bound = worst case = O notation
    /// Lower bound = best possible time
    /// When upper bound = lower bound, you have an optimal awesome algorithm for time
    /// Not related to space usage being good or bad, however.
    /// Make sure to consider both time- and space- optimization. 
    /// 
    /// Mergesort is optimal with # compares (N log N for both upper and lower bound).
    /// Mergesort is NOT optimal with respect to space usage.
    /// </summary>
    class Ch3Notes
    {
        
    }
}
